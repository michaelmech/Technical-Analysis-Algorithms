# -*- coding: utf-8 -*-
"""Copy of  TA_Live(Test)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11QSTrD7SI6K19U1ZH9vwMS9TO5pxUSIl
"""

!pip install pandas-datareader
!pip install --upgrade ta
!pip install -U git+https://github.com/twopirllc/pandas-ta
!pip install nest-asyncio
!pip install -U git+https://github.com/mariostoev/finviz
!pip install git+git://github.com/peerchemist/finta.git
!pip install tiingo
 
#!pip install pandas_ta
#!pip install robin_stocks
!pip install finviz
!pip install PyPortfolioOpt
#!pip install yfinance
!pip install -U yfinance
 
 
!pip install td-ameritrade-python-api==0.3.5
!pip install selenium
!pip install webdriver_manager
!pip install fracdiff
 
!pip install scikit-learn==0.23.
!pip install portfoliolab
!pip install --upgrade numpy
!pip install pandas==1.3.0

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader.data as pdr
import ta
import pandas_ta 
from pandas import DataFrame, Series
import nest_asyncio
nest_asyncio.apply()
import finviz
from finviz.screener import Screener
from finta import TA
import tiingo
from tiingo import TiingoClient
import requests
 
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
import pypfopt
from pypfopt import objective_functions
 
from google.colab import files
import csv
from collections import OrderedDict
import json
 
#import robin_stocks as rs
from dateutil import parser
import scipy
from scipy import stats as scipy_stats
 
 
import yfinance as yf
yf.pdr_override()
 
import td
from td.client import TDClient
 
import requests
import datetime as dt
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
 
import selenium
from selenium import webdriver
from webdriver_manager.opera import OperaDriverManager
import json
from fracdiff import FracdiffStat
from sklearn.preprocessing import MinMaxScaler
 
import sklearn

import warnings
warnings.simplefilter("ignore")

# Commented out IPython magic to ensure Python compatibility.
import cython
# %load_ext cython

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import pandas_datareader.data as pdr
import ta
import pandas_ta 
from pandas import DataFrame, Series
import nest_asyncio
nest_asyncio.apply()
import finviz
from finviz.screener import Screener
from finta import TA
import tiingo
from tiingo import TiingoClient
import requests
 
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
import pypfopt
from pypfopt import objective_functions
 
from google.colab import files
import csv
from collections import OrderedDict
import json
 
#import robin_stocks as rs
from dateutil import parser
import scipy
from scipy import stats as scipy_stats
 
 
import yfinance as yf
yf.pdr_override()
 
import td
from td.client import TDClient
 
import requests
import datetime as dt
from statistics import mean,median
import urllib
from urllib.parse import urlencode, quote_plus
 
import selenium
from selenium import webdriver
from webdriver_manager.opera import OperaDriverManager
import json
from fracdiff import FracdiffStat
from sklearn.preprocessing import MinMaxScaler
 
import sklearn
 
 
import warnings
warnings.simplefilter("ignore")
 
def yahooTA(ticker,freq):
  
  sixty=['1m','2m','5m','15m','30m','15m']
 
  if freq in sixty:
    data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
    data.index=data.index.tz_convert('US/Pacific')
  
  elif freq=='1h':
    data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
    data.index=data.index.tz_convert('US/Pacific')
  
  elif freq=='1d' or freq=='1wk':
    #data=pdr.get_data_yahoo(ticker,interval=freq)
    data=pdr.get_data_yahoo(ticker,interval=freq,period='360d')
  
  elif freq=='1mo':
    data=pdr.get_data_yahoo(ticker,interval=freq,period='1200d')
   
  data=data.drop('Adj Close',axis=1)
  #data=data.reset_index()
  
  data['mfi2']=ta.volume.money_flow_index(high=data['High'],low=data['Low'],close=data['Close'],volume=data['Volume'],window=2)
  data['mfi10']=ta.volume.money_flow_index(high=data['High'],low=data['Low'],close=data['Close'],volume=data['Volume'],window=10)
  
  data['rsi10']=ta.momentum.rsi(close=data['Close'],window=10)
  data['rsi2']=ta.momentum.rsi(close=data['Close'],window=2)            
 
  data['hma10']=pandas_ta.hma(data['Close'],length=10)
  data['hma20']=pandas_ta.hma(data['Close'],length=20)
  data['hma50']=pandas_ta.hma(data['Close'],length=50)
  #data['hma150']=pandas_ta.hma(data['Close'],length=150)
  #data['ema200']=ta.trend.ema_indicator(data['Close'],window=200)
  data['ema10']=pandas_ta.ema(data['Close'],length=10)
  data['ema20']=pandas_ta.ema(data['Close'],length=20)
  data['ema50']=pandas_ta.ema(data['Close'],length=50)
 
  #data['natr']=pandas_ta.natr(data['High'],data['Low'],data['Close'],length=10)
 
  psar=pandas_ta.psar(data['High'],data['Low'],data['Close'],0.4,0.4,0.4)
    
  psar['PSARl_0.4_0.4'].fillna(psar['PSARs_0.4_0.4'],inplace=True)
  data['psar']=psar['PSARl_0.4_0.4']
 
  psar=pandas_ta.psar(data['High'],data['Low'],data['Close'],2,2,2)
 
  psar['PSARl_2.0_2.0'].fillna(psar['PSARs_2.0_2.0'],inplace=True)
  data['stop_loss']=psar['PSARl_2.0_2.0']
 
  data['hbb']=ta.volatility.bollinger_hband(data['Close'])
  data['lbb']=ta.volatility.bollinger_lband(data['Close'])
     
  data['close_returns']=data.Close.pct_change(periods=1)
  data['price_roc']=data.Close.diff()
  data['vol_roc']=data.Volume.diff().ewm(span=10).mean()
 
  data['Volume'].iloc[:data['hma10'].isnull().sum()]=data['hma10'].iloc[:data['hma10'].isnull().sum()]
 
  data['vol_ema']=data['Volume'].ewm(span=10).mean()
  
  try:
    keltner=pandas_ta.kc(data['High'],data['Low'],data['Close'],scale=1.5,mamode='ema')
    keltner.columns=['lkeltner','mkeltner','hkeltner']
  
  except:
    keltner=pandas_ta.kc(data['High'],data['Low'],data['Close'],scale=1.5,mamode='ema',length=12)
    keltner.columns=['lkeltner','mkeltner','hkeltner']
    pass
 
  data=pd.concat([data,keltner],axis=1)
  
  data.columns=[col.lower() for col in data.columns]
 
  data['cci10']=pandas_ta.cci(data['low'],data['high'],data['close'],length=10)
  data['cci2']=pandas_ta.cci(data['low'],data['high'],data['close'],length=2)
 
  #data['qstick10']=pandas_ta.qstick(data['open'],data['close'],length=10)
  #data['qstick2']=pandas_ta.qstick(data['open'],data['close'],length=2)
 
  #data['kvo']=pandas_ta.kvo(data['high'],data['low'],data['close'],data['volume'],fast=20,long=50,length_sig=10)['KVOs_20_55_13']
  #data['eri']=pandas_ta.eri(data['high'],data['low'],data['close'],length=10)
  
  return data
 
def Prices(stocks_list,freq):
 
  prices_df=pd.DataFrame()
  sixty=['1m','2m','5m','30m','15m']
  
  for ticker in stocks_list:
    
    if freq in sixty:
      data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
      data.index=data.index.tz_convert('US/Pacific')
    
    elif freq=='1h':
      data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
      data.index=data.index.tz_convert('US/Pacific')
    
    else:
      data=pdr.get_data_yahoo(ticker,interval=freq)
      
    prices_df[str(ticker)]=data['Close']
      
      #prices_df=prices_df.dropna(axis=0)
 
  return prices_df
 
def Last_Prices(ticker_list,freq):
  sixty=['1m','2m','5m','30m','15m']
  price_series=pd.Series()
 
  for ticker in ticker_list:
    
    if freq in sixty:
      data=pdr.get_data_yahoo(ticker,interval=freq,period='60d')
      data.index=data.index.tz_convert('US/Pacific')
    
    elif freq=='1h':
      data=pdr.get_data_yahoo(ticker,interval=freq,period='710d')
      data.index=data.index.tz_convert('US/Pacific')
    
    else:
      data=pdr.get_data_yahoo(ticker,interval=freq)
  
    price_series[ticker]=data.Close.iloc[-1]
 
  return price_series
 
def yf_fetch(ticker_list):
 
  returns_df=pd.DataFrame()
  prices_df=pd.DataFrame()
 
  for ticker in ticker_list:
    data=yf.Ticker(ticker).history(period='max')
   
    data['returns']=data.Close.pct_change()
 
    returns_df[str(ticker)]=data['returns']
    prices_df[str(ticker)]=data['Close']
  
  return returns_df,prices_df
 
def yf_intraday(ticker_list):
  returns_df=pd.DataFrame()
  prices_df=pd.DataFrame()
 
  for ticker in ticker_list:
    data=yf.Ticker(ticker).history(period='60d',interval='15m')
    data['returns']=data.Close.pct_change()
 
    returns_df[str(ticker)]=data['returns']
    prices_df[str(ticker)]=data['Close']
 
  return returns_df,prices_df
 
def Returns(stocks_list):
 
  returns_df=pd.DataFrame()
  
  for stock_symbol in stocks_list:
     
    data=pdr.get_data_yahoo(stock_symbol.replace('.',''))
    
    returns_df[str(stock_symbol)]=data['Close'].pct_change()
    
    #prices_df=prices_df.dropna(axis=0)
 
  return returns_df
 
def Blacklitter(prices_df,view_dict):
  risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
  cov_matrix=risk_model.oracle_approximating()
 
  view_series=pd.Series(view_dict)
 
  #cov_matrix=pypfopt.risk_models.fix_nonpositive_semidefinite(cov_matrix,fix_method='spectral')
 
  #if np.linalg.det(cov_matrix)==0:
    #cov_matrix=cov_matrix+0.0000001
  
  bl=pypfopt.black_litterman.BlackLittermanModel(cov_matrix=cov_matrix,absolute_views=view_series)
 
  weights=bl.bl_weights()
  weights=bl.clean_weights(cutoff=0.000001,rounding=8)
 
  return dict(weights)
 
def Blacklitter2(prices_df,views_dict,method):
  view_series=pd.Series(views_dict)
  view_series=view_series[view_series!=0]
  hrp_weights=HR_Paritize(prices_df,views_dict,method)
  hrp_series=pd.Series(hrp_weights) 
 
  risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
  cov_matrix=risk_model.oracle_approximating()
 
  repeat=np.array(hrp_series-1/len(hrp_series))
  P=np.vstack([repeat]*len(view_series))
  Q=np.array(view_series).reshape(-1,1)
 
  bl=pypfopt.black_litterman.BlackLittermanModel(cov_matrix=cov_matrix,Q=Q,P=P)
  weights=bl.bl_weights()
  weights=bl.clean_weights(cutoff=0.000001,rounding=8)
 
  if np.isinf(pd.Series(weights)).sum()==len(weights):
    one_df=pd.Series([1 if x>0 else -1 for x in pd.Series(weights)],index=weights.keys())
    
    one_df=one_df/(abs(one_df)).sum()
    weights=dict(one_df)
 
  return dict(weights)
 
def HR_Paritize(prices_df,views_dict,method='median'):
 
  if len(views_dict)==1:
    return {x:1 for x in views_dict}
  
  elif len(views_dict)==0:
    return {}
  
  else:
    
    views_df=pd.Series(views_dict)
 
    prices_df=prices_df[views_df.index]
 
    risk_model=pypfopt.risk_models.CovarianceShrinkage(prices_df)
    cov_matrix=risk_model.oracle_approximating()
 
    hrp=pypfopt.hierarchical_portfolio.HRPOpt(cov_matrix=cov_matrix)
 
    abs_weights=dict(hrp.optimize(method))
    
    return abs_weights
 
def norm(x):
    
    nom = (x - x.min())*1.33
    denom = x.max() - x.min()
    return  nom/denom
 
def tanm(x):
  e=2.71828
  numerator=(e**(15*x)-e**(7.5))
  denominator=(e**(15*x)+e**(7.5))**-1
 
  if isinstance(x,float)==True:
    if np.isnan(numerator * denominator)==True:
      return 1
    
    else:
      return numerator*denominator
    
  else:
    return numerator*denominator
 
def as_currency(amount):
  
    if amount >= 0:
        return float('{:.2f}'.format(amount))
    else:
        return float('-{:.2f}'.format(-amount))
 
def single_trail(ticker,size,TDSession,account_id,stop_loss,short=False):
 
    if short:
      instruction='BUY_TO_COVER'
    
    else:
      instruction='SELL'
 
    order={
        "orderType": "TRAILING_STOP",
        "stopPriceOffset": stop_loss,
        "stopPriceLinkType": "VALUE",
        "stopPriceLinkBasis": "ASK",
        "stopType": "STANDARD",
        "session": "NORMAL",
        "duration": "GOOD_TILL_CANCEL",
        "orderStrategyType": "SINGLE",
        "orderLegCollection": [
          {
            "instruction": instruction,
            "quantity": size,
            "instrument": {
              "symbol": ticker,
              "assetType": "EQUITY"
            }
          }]}
    
    TDSession.place_order(account_id,order)
 
def single_stop(ticker,size,stop_price):
    
    stop_market={
    "orderType": "STOP",
    "session": 'NORMAL',
    "duration": "GOOD_TILL_CANCEL",
    "stopPrice": stop_price,
    "orderStrategyType": "SINGLE",
    "orderLegCollection": [
      {
        "instruction": "SELL",
        "quantity": size,
        "instrument": {
          "symbol": ticker,
          "assetType": "EQUITY"
        }
      }
    ]
  }
    return stop_market
 
def buy_anytime(ticker,size,TDSession,account_id,short=False):
    
    ticker=ticker.upper()
    size=abs(size)
    quote=TDSession.get_quotes(instruments=[ticker])
    
      
    if short:
      instruction='SELL_SHORT'
      price=quote[ticker]['bidPrice']-0.01
    
    else:
       instruction='BUY'
       price=quote[ticker]['askPrice']+0.01
    
    price=as_currency(price)
 
    order={
    "orderType": "LIMIT",
    "session": 'SEAMLESS',
    "duration": "DAY",
    "price": price,
    "orderStrategyType": "SINGLE",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "symbol": ticker,
          "assetType": "EQUITY"
        }
      }
    ]
  }
    TDSession.place_order(account_id,order)
 
def sell_anytime(ticker,size,TDSession,account_id,short=False):
    
    ticker=ticker.upper()
    size=abs(size)
    quote=TDSession.get_quotes(instruments=[ticker])
      
    if short:
      instruction='BUY_TO_COVER'
      price=quote[ticker]['askPrice']+0.01
    
    else:
       instruction='SELL'
       price=quote[ticker]['bidPrice']-0.01
    
    price=as_currency(price)
    
    order={
    "orderType": "LIMIT",
    "session": 'SEAMLESS',
    "duration": "DAY",
    "price": price,
    "orderStrategyType": "SINGLE",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "symbol": ticker,
          "assetType": "EQUITY"
        }
      }
    ]
  }
     
    TDSession.place_order(account_id,order)
 
def market_order(ticker,size,TDSession,account_id,sell=False,short=False):
  size=abs(size)
  ticker=ticker.upper()
    
  if short and sell:
    instruction='BUY_TO_COVER'
  
  elif short and not sell:
    instruction='SELL_SHORT'
  
  elif sell and not short:
    instruction='SELL'
 
  else:
    instruction='BUY'
      
  order={
  "orderType": "MARKET",
  "session": 'NORMAL',
  "duration": "DAY",
  "orderStrategyType": "SINGLE",
  "orderLegCollection": [
    {
      "instruction": instruction,
      "quantity": size,
      "instrument": {
        "symbol": ticker,
        "assetType": "EQUITY"
      }
    }
  ]
}
 
  TDSession.place_order(account_id,order)
 
def stop_market(ticker,size,stop_price,TDSession,account_id,sell=False,short=False):
  size=abs(size)
  ticker=ticker.upper()
  
  if short and sell:
    instruction='BUY_TO_COVER'
  
  elif short and not sell:
    instruction='SELL_SHORT'
  
  elif sell and not short:
    instruction='SELL'
 
  else:
    instruction='BUY'
 
  order={
 
    "orderType": "STOP",
    "session": "NORMAL",
    "duration": "DAY",
    "stopPrice": stop_price,
    "orderStrategyType": "SINGLE",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "symbol": ticker,
          "assetType": "EQUITY"
        }
      }
    ]
  }
  
  TDSession.place_order(account_id,order)
  
 
def conditional_order(ticker,size,stop_size,stop_price,TDSession,account_id,short=False,sell=False):
  
  size=abs(size)
  stop_size=abs(stop_size)
  ticker=ticker.upper()
 
  if not (short and sell):
    bid=TDSession.get_quotes([ticker])[ticker.upper()]['bidPrice']
    instruction='BUY'
    stop_instruction='SELL'
    stop_price=as_currency(stop_price if stop_price <bid else bid)
  
  elif short and not sell:
    ask=TDSession.get_quotes([ticker])[ticker.upper()]['askPrice']
    instruction='SELL_SHORT'
    stop_instruction='BUY_TO_COVER'
    stop_price=as_currency(stop_price if stop_price >ask else ask)
  
  elif not short and sell:
    bid=TDSession.get_quotes([ticker])[ticker.upper()]['bidPrice']
    instruction='SELL'
    stop_instruction='SELL'
    stop_price=as_currency(stop_price if stop_price >bid else bid)
  
  else:
    ask=TDSession.get_quotes([ticker])[ticker.upper()]['askPrice']
    instruction='BUY_TO_COVER'
    stop_instruction='BUY_TO_COVER'
    stop_price=as_currency(stop_price if stop_price >ask else ask)
    
  trigger_order={
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
      {
 
        "orderStrategyType": "SINGLE",
        "session": "NORMAL",
        "duration": "DAY",
        "orderType": "STOP",
        "stopPrice": stop_price,
        "orderLegCollection": [
          {
            "instruction": stop_instruction,
            "quantity": stop_size,
            "instrument": {
              "assetType": "EQUITY",
              "symbol": ticker
            }
          }
        ]
      }
    ]
  }
 
  TDSession.place_order(account_id,trigger_order)
 
 
def two_trigger_order(ticker,negate_size,size,stop_size,stop_price,TDSession,account_id,short=False):
  negate_size=abs(negate_size)
  stop_size=abs(stop_size)
  size=abs(size)
  ticker=ticker.upper()
 
  if not short:
    bid=TDSession.get_quotes([ticker])[ticker.upper()]['bidPrice']
    instruction='BUY'
    stop_instruction='SELL'
    negate_instruction='BUY_TO_COVER'
    stop_price=as_currency(stop_price if stop_price <bid else bid)
    
  else:
    ask=TDSession.get_quotes([ticker])[ticker.upper()]['askPrice']
    instruction='SELL_SHORT'
    stop_instruction='BUY_TO_COVER'
    negate_instruction='SELL'
    stop_price=as_currency(stop_price if stop_price >ask else ask)
  
  trigger_trigger_order={
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": negate_instruction,
        "quantity": negate_size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
      {
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
      {
 
        "orderStrategyType": "SINGLE",
        "session": "NORMAL",
        "duration": "DAY",
        "orderType": "STOP",
        "stopPrice": stop_price,
        "orderLegCollection": [
          {
            "instruction": stop_instruction,
            "quantity": stop_size,
            "instrument": {
              "assetType": "EQUITY",
              "symbol": ticker
            }
          }
        ]
      }
    ]
  }
    ]
  }
  
  TDSession.place_order(account_id,trigger_trigger_order)
 
def two_trail_order(take_profit,stop_loss,ticker,negate_size,size,stop_size,TDSession,account_id,short=False):
  print('two_trail_order')
  negate_size=abs(negate_size)
  stop_size=abs(stop_size)
  take_size=stop_size
  size=abs(size)
  ticker=ticker.upper()
  price=TDSession.get_quotes([ticker.upper()])[ticker.upper()]['lastPrice']
 
  if not short:
    
    instruction='BUY'
    stop_instruction='SELL'
    negate_instruction='BUY_TO_COVER'
    take_profit+=price
    
  else:
    
    instruction='SELL_SHORT'
    stop_instruction='BUY_TO_COVER'
    negate_instruction='SELL'
    take_profit=price-take_profit
  
  take_instruction=stop_instruction
  take_profit=as_currency(take_profit)
  
  trigger_trigger_order={
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": negate_instruction,
        "quantity": negate_size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
      {
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
       { 
      "orderStrategyType": "OCO",
      "childOrderStrategies": [
        {     
          "orderType": "LIMIT",
          "session": "NORMAL",
          "duration": "GOOD_TILL_CANCEL",
          "price": take_profit,
          'orderStrategyType': 'SINGLE',
          "orderLegCollection": [
            {
              "instruction": take_instruction,
              "quantity": take_size,
              "instrument": {
                "assetType": "EQUITY",
                "symbol": ticker
              }
            }
          ]
        },
        {
          
          "orderType": "TRAILING_STOP",
         "stopPriceOffset": stop_loss,
         "stopPriceLinkType": 'VALUE',
         'stopPriceLinkBasis': "ASK",
         'stopType': 'STANDARD',
          "session": "NORMAL",
          "duration": "GOOD_TILL_CANCEL",
          "orderStrategyType": "SINGLE",
          "orderLegCollection": [
            {
              "instruction": stop_instruction,
              "quantity": stop_size,
              "instrument": {
                "assetType": "EQUITY",
                "symbol": ticker
              }
            }
          ]
        }
      ]
    }
    ]
  }
    ]
  }
  
  
  print(TDSession.place_order(account_id,trigger_trigger_order))
 
def conditional_trail_order(take_profit,stop_loss,ticker,size,stop_size,TDSession,account_id,short=False,sell=False):
  
  
  size=abs(size)
  stop_size=abs(stop_size)
  take_size=stop_size
  ticker=ticker.upper()
  price=TDSession.get_quotes([ticker.upper()])[ticker.upper()]['lastPrice']
 
  if not short and not sell:
    
    instruction='BUY'
    stop_instruction='SELL'
    take_profit+=price
    
  
  elif short and not sell:
    
    instruction='SELL_SHORT'
    stop_instruction='BUY_TO_COVER'
    take_profit=price-take_profit
  
  elif not short and sell:
    
    instruction='SELL'
    stop_instruction='SELL'
    take_profit+=price
    
  
  else:
    
    instruction='BUY_TO_COVER'
    stop_instruction='BUY_TO_COVER'
    take_profit=price-take_profit

  take_instruction=stop_instruction
  take_profit=max(0.01,as_currency(take_profit))
  

  trigger_order={
    "orderStrategyType": "TRIGGER",
    "session": "NORMAL",
    'duration':'DAY',
    "orderType": "MARKET",
    "orderLegCollection": [
      {
        "instruction": instruction,
        "quantity": size,
        "instrument": {
          "assetType": "EQUITY",
          "symbol": ticker
        }
      }
    ],
    
    "childOrderStrategies": [
    {
      
      "orderStrategyType": "OCO",
      "childOrderStrategies": [
        {
          
          "orderStrategyType": "SINGLE",
          "session": "NORMAL",
          "duration": "GOOD_TILL_CANCEL",
          "orderType": "LIMIT",
          "price": take_profit,
          "orderLegCollection": [
            {
              "instruction": take_instruction,
              "quantity": take_size,
              "instrument": {
                "assetType": "EQUITY",
                "symbol": ticker
              }
            }
          ]
        },
        {
          
          "orderType": "TRAILING_STOP",
         "stopPriceOffset": stop_loss,
         "stopPriceLinkType": 'VALUE',
         'stopPriceLinkBasis': "ASK",
         'stopType': 'STANDARD',
          "session": "NORMAL",
          "duration": "GOOD_TILL_CANCEL",
          "orderStrategyType": "SINGLE",
          "orderLegCollection": [
            {
              "instruction": stop_instruction,
              "quantity": stop_size,
              "instrument": {
                "assetType": "EQUITY",
                "symbol": ticker
              }
            }
          ]
        }
      ]
    }
  ]
}
 
  TDSession.place_order(account_id,trigger_order)
 
def bband(data):
  if (data['high'].iloc[-1]>data['hbb'].iloc[-1] and data['close'].iloc[-1]>data['hbb'].iloc[-1]) or (data['low'].iloc[-1]<data['lbb'].iloc[-1] and data['close'].iloc[-1]>data['hbb'].iloc[-1]):
    return 1
  
  elif (data['high'].iloc[-1]>data['hbb'].iloc[-1] and data['close'].iloc[-1]<data['hbb'].iloc[-1]) or (data['low'].iloc[-1]<data['lbb'].iloc[-1] and data['close'].iloc[-1]<data['hbb'].iloc[-1]):
    return -1
  
  else:
    return 0
 
def supertrend(data):
  data['super']=pandas_ta.supertrend(data['high'],data['low'],data['close'],length=2,multiplier=1).iloc[:,1]
  
  return data['super'].iloc[-1]/2

def momentum(data):
  squeeze=squeezed(data)*psar_trend(data)
  roc=data['price_roc'].iloc[-5:].mean()
  
  if (squeeze==1) or (squeeze==-1):
    
    return scipy.special.expit(roc)
  
  else:
    return 0
 
def mfi2(data):
  return -0.5*(data['mfi2'].iloc[-1]>=95)+0.5*(data['mfi2'].iloc[-1]<=5)
 
def rsi2(data):
  return -0.5*(data['rsi2'].iloc[-1]>=95)+0.5*(data['rsi2'].iloc[-1]<=5)
 
def cci2(data):
  return -0.5*(data['cci2'].iloc[-1]>=65)+0.5*(data['cci2'].iloc[-1]<=-65)
 
def mfi10(data):
  if psar_trend(data)==1 and (data['mfi10'].iloc[-1]>=90 or data['mfi10'].iloc[-1]<=40):
    return tanm(1-data['mfi10'].iloc[-1]/100)
  
  elif psar_trend(data)==-1 and (data['mfi10'].iloc[-1]>=60 or data['mfi10'].iloc[-1]<=10):
    return tanm(1-data['mfi10'].iloc[-1]/100)
  
  else:
    return 0
 
def rsi10(data):
  if psar_trend(data)==1 and (data['rsi10'].iloc[-1]>=80 or data['rsi10'].iloc[-1]<=35):
    return tanm(1-data['rsi10'].iloc[-1]/100)
  
  elif psar_trend(data)==-1 and (data['rsi10'].iloc[-1]>=60 or data['rsi10'].iloc[-1]<=25):
    return tanm(1-data['rsi10'].iloc[-1]/100)
  
  else:
    return 0
 
def cci10(data):
  if psar_trend(data)==-1 and (data['cci10'].iloc[-1]>=100):
    return tanm(1-data['cci10'].iloc[-1]/100)
  
  elif psar_trend(data)==1 and (data['cci10'].iloc[-1]<=-100):
    return tanm(1-data['cci10'].iloc[-1]/100)
  
  else:
    return 0
 
def hma_crossback(data):
  if data['close'].iloc[-1]>=data['hma50'].iloc[-1] and data['hma10'].iloc[-1]>=data['hma20'].iloc[-1] and data['hma10'].iloc[-2]<=data['hma20'].iloc[-2]:
    return 1
  elif data['close'].iloc[-1]<=data['hma50'].iloc[-1] and data['hma10'].iloc[-1]<=data['hma20'].iloc[-1] and data['hma10'].iloc[-2]>=data['hma20'].iloc[-2]:
    return -1
  else:
    return 0
 
def ema_crossback(data):
  if data['close'].iloc[-1]>=data['ema50'].iloc[-1] and data['ema10'].iloc[-1]>=data['ema20'].iloc[-1] and data['ema10'].iloc[-2]<=data['ema20'].iloc[-2]:
    return 1
  elif data['close'].iloc[-1]<=data['ema50'].iloc[-1] and data['ema10'].iloc[-1]<=data['ema20'].iloc[-1] and data['ema10'].iloc[-2]>=data['ema20'].iloc[-2]:
    return -1
  else:
    return 0

def engulfing(data):
  if (data.close.iloc[-2]< data.open.iloc[-2]) & (data.close.iloc[-1] > data.open.iloc[-2]) & (data.open.iloc[-1] < data.close.iloc[-2]):
    return 1
  elif (data.close.iloc[-2]> data.open.iloc[-2]) & (data.close.iloc[-1] < data.open.iloc[-2]) & (data.open.iloc[-1] > data.close.iloc[-2]):
    return -1
  else:
    return 0
 
def psar_reversal(data):
  if data['close'].iloc[-1]>data['psar'].iloc[-1] and data['close'].iloc[-2]<data['psar'].iloc[-2]:
    return 1
  
  elif data['close'].iloc[-1]<data['psar'].iloc[-1] and data['close'].iloc[-2]>data['psar'].iloc[-2]:
    return -1
    
  else:
    return 0
 
def squeezed(data):
  if data['hbb'].iloc[-1]>data['hkeltner'].iloc[-1] and data['lbb'].iloc[-1]<data['lkeltner'].iloc[-1]:
    return 1
  
  elif data['hbb'].iloc[-1]<data['hkeltner'].iloc[-1] and data['lbb'].iloc[-1]>data['lkeltner'].iloc[-1]:
    return -1
  
  else:
    return 0
 
def volume_counter(data):
  orig_data=data.copy()
  data=data[['volume','vol_ema','close_returns']].iloc[-10:]
 
  data['label']=0
  data['label'][data['close_returns']>0]=1
  data['label'][data['close_returns']<0]=-1
 
  plus_counter=0
  neg_counter=0
 
  for idx in range(len(data)):
    if data['label'].iloc[idx]==1 and data['volume'].iloc[idx]>=data['vol_ema'].iloc[idx]:
      plus_counter+=1
    
    elif data['label'].iloc[idx]==-1 and data['volume'].iloc[idx]>=data['vol_ema'].iloc[idx]:
      neg_counter+=1
    
    else:
      continue
 
  sum_counter=plus_counter-neg_counter
  if (sum_counter>0 and plus_counter>=3) and (psar_trend(orig_data)==1):
    
    return scipy.special.expit(sum_counter)
 
  elif (sum_counter<0 and neg_counter>=3) and (psar_trend(orig_data)==-1):
    return scipy.special.expit(sum_counter)
 
  else:
    return 0
 
def dday(data):
  window=data.iloc[-75:-50]
  counter=0
  for i in range(len(window)-1):
    if window['close_returns'].iloc[i+1]<=-0.002 and window['volume'].iloc[i+1]>window['volume'].iloc[i]:
      counter+=1
 
  return -1*(counter>=4)+0

def ichimoku(data):
 
  past,future=pandas_ta.ichimoku(data['high'],data['low'],data['close'])
  past.columns=['spanA','spanB','conversion','base','lag']
  past=past.drop(['lag'],axis=1)
  future.columns=['spanA','spanB']
 
  ichimoku_df=past.append(future)
 
  data=pd.concat([data,ichimoku_df],axis=1)
  
  data['ichi_score']=0
 
  ichi_up=data['ichi_score'][data['close']>data['conversion']][data['close']>data['base']]
 
  up1=ichi_up[data['close']>data['spanA']][data['spanA']>data['spanB']]+0.5
 
  up2=ichi_up[data['spanA'].shift(-26)>data['spanB'].shift(-26)][data['spanA'].shift(-25)<=data['spanB'].shift(-25)]+0.5#future
 
  ichi_down=data['ichi_score'][data['close']<data['conversion']][data['close']<data['base']]
 
  down1=ichi_down[data['close']<data['spanA']][data['spanA']<data['spanB']]-0.5
 
  down2=ichi_down[data['spanA'].shift(-26)<data['spanB'].shift(-26)][data['spanA'].shift(-25)>=data['spanB'].shift(-25)]-0.5 #future
 
  up3=data['ichi_score'][data['close']>data['spanA']][data['spanA']>data['spanB']][data['close'].shift()<=data['spanA'].shift()]+0.5
  down3=data['ichi_score'][data['close']<data['spanA']][data['spanA']<data['spanB']][data['close'].shift()>=data['spanA'].shift()]-0.5
 
  ichi_list=[data['ichi_score'],up1,up2,up3,down1,down2,down3]
 
  ichi_scores=pd.concat(ichi_list,axis=1).sum(1)
  
  return ichi_scores.iloc[:-26]
 
def psar_trend(data):  
  return -1*(data['psar'].iloc[-1]>data['close'].iloc[-1])+1*(data['psar'].iloc[-1]<data['close'].iloc[-1])
 
def necklace(data,momentums=False):  #getting the results for the last day of data
  
  long_mfi=mfi10(data)/3
  long_rsi=rsi10(data)/3
  long_cci=cci10(data)/3
  
  try:
    hma_cross=hma_crossback(data)
    ema_cross=ema_crossback(data)
    
  except:
    ema_cross=0
    hma_cross=0
    pass
  
  psar=psar_reversal(data)
  bollinger=bband(data)
  
  dist=dday(data)
  engulf=engulfing(data)
 
 
  try:
    moku=ichimoku(data).iloc[-1]
  except:
    moku=0
    pass
 
  if momentum: 
    vol_count=volume_counter(data)
    score_list=[long_mfi,long_rsi,ema_cross,psar,hma_cross,moku,bollinger,long_cci,vol_count,dist,engulf]
  
  else:
    score_list=[long_mfi,long_rsi,ema_cross,psar,hma_cross,moku,bollinger,long_cci,dist,engulf]
 
  if any(score_list):
    aggregate=sum(score_list)  
  
    short_rsi=rsi2(data)/2
    short_mfi=mfi2(data)/3
    short_cci=cci2(data)/3
    
    if momentums:
      mom=momentum(data)
 
      tech=[short_rsi,short_mfi,mom,short_cci]
    
    else:
      tech=[short_rsi,short_mfi,short_cci]
 
    aggregate+=sum(tech)
  
    return aggregate
  
  else:
    return 0
 
def generate_current_views(ticker_list,freq,momentums=False):
  data_dict={}
  views_series=pd.Series(name='views')
  for ticker in ticker_list:
    data=yahooTA(ticker,freq)
  
    data_dict[ticker]=data
    weekly=yahooTA(ticker,'1wk')
    monthly=yahooTA(ticker,'1mo')
    
    if momentums:
      result=necklace(data,momentums=True)
      weekly_result=necklace(weekly,momentums=True)
      monthly_result=necklace(monthly,momentums=True)

    else:
      result=necklace(data)
      weekly_result=necklace(weekly)
      monthly_result=necklace(monthly)

    views_series.loc[ticker]=result+weekly_result/2+monthly_result/3
 
  return dict(views_series[abs(views_series)>0.2]),data_dict
 
def get_current_shares(ticker_list,capital,freq,HRP=False,long_only=False,bl1=False,method='median'):
  
  _,prime_prices_df=yf_fetch(ticker_list)

  if bl1:
    views_dict,data_dict=generate_current_views(ticker_list,freq,momentums=True)
  else:
    views_dict,data_dict=generate_current_views(ticker_list,freq)

  views_dict={x:y for x,y in views_dict.items() if y!=0}
  
  last_prices=prime_prices_df.iloc[-1] 
 
  if HRP and not long_only:
    neg_dict={x:y for x,y in views_dict.items() if y<0}
    pos_dict={x:y for x,y in views_dict.items() if y>0}
    pos_weights=HR_Paritize(prime_prices_df,pos_dict,method)
    neg_weights=HR_Paritize(prime_prices_df,neg_dict,method)
    neg_weights={x:-y for x,y in neg_weights.items()}
    comb_weights={**pos_weights,**neg_weights}
    weights_df=pd.Series(comb_weights.copy())
  
  elif HRP and long_only:
    views_dict={x:y for x,y in views_dict.items() if y>0}
    weights_df=pd.Series(HR_Paritize(prime_prices_df,views_dict,method))
 
  else:
    if bl1:
      bl_weights=Blacklitter(prime_prices_df[views_dict.keys()],views_dict) 
    else:
      bl_weights=Blacklitter2(prime_prices_df[views_dict.keys()],views_dict,method) #2
    weights=bl_weights.copy()
    if not HRP and long_only:
      weights_df=pd.Series(weights)
      if len(weights_df[weights_df>0])>0:
        weights_df=weights_df[weights_df>0]
    
      else:
        return weights_df
    
    else:
      weights_df=pd.Series(weights)
 
      
  if abs(weights_df).sum()!=1:
    corrected_df=weights_df/abs(weights_df).sum() 
      
  else:
    corrected_df=weights_df
 
  sign_df=corrected_df/abs(corrected_df)
  abs_weights=dict(abs(corrected_df))
 
  sharer=pypfopt.discrete_allocation.DiscreteAllocation(abs_weights,last_prices,capital,0.000001) #0.000001
 
  shares_dict=sharer.greedy_portfolio()[0]
 
  shares_dict={key:shares_dict[key]*sign_df[key] for key in shares_dict}
 
  return shares_dict,data_dict
 
def buy_diff_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
 
  conditional_trail_order(take_profit,stop_loss,ticker,abs(diff_df[ticker]),shares_dict[ticker],TDSession,account_id)
 
def sell_diff_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
 
  conditional_trail_order(take_profit,stop_loss,ticker,abs(diff_df[ticker]),shares_dict[ticker],TDSession,account_id,sell=True,short=False)
 
def cover_diff_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
 
  conditional_trail_order(take_profit,stop_loss,ticker,abs(diff_df[ticker]),shares_dict[ticker],TDSession,account_id,sell=True,short=True)
 
def buy_otota(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
  
  #two_trail_order(take_profit,stop_loss,ticker,already_dict[ticker],shares_dict[ticker],shares_dict[ticker],TDSession,account_id)

  conditional_trail_order(take_profit,stop_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id)
 
def short_diff_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
  
  conditional_trail_order(take_profit,stop_loss,ticker,abs(diff_df[ticker]),shares_dict[ticker],TDSession,account_id,short=True,sell=False)
 
def short_otota(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
  
  #two_trail_order(take_profit,stop_loss,ticker,already_dict[ticker],shares_dict[ticker],shares_dict[ticker],TDSession,account_id,short=True)
  conditional_trail_order(take_profit,stop_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id,short=True)
 
def buy_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
  
  conditional_trail_order(take_profit,stop_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id)
 
def short_conditional_order(take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession):
  
  conditional_trail_order(take_profit,stop_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id,short=True)
 
def in_already(ticker,already_dict):
  return (ticker not in already_dict) *'' +(ticker in already_dict) * 'already'
    
def shares_sign(ticker,shares_dict):
  return (shares_dict[ticker]>0) *'shares>0' + (shares_dict[ticker]<0) * 'shares<0'
 
def sign(ticker,sign_df,diff_df):
  
  return (ticker not in sign_df)*''+(ticker in sign_df and sign_df[ticker]<0)*'sign<0'+(ticker in sign_df and sign_df[ticker]>0)*'sign>0'
 
def difference(ticker,diff_df,sign_df):
 
  return (ticker not in sign_df or ticker not in diff_df)*''+((ticker in sign_df and ticker in diff_df) and (sign_df[ticker]>0 and diff_df[ticker]>0))*'diff>0'+((ticker in sign_df and ticker in diff_df) and sign_df[ticker]>0 and diff_df[ticker]<0)*'diff<0'
 
def execute_brokerage(ticker_list):
 
  #global account_id,TDSession
 
  TDSession=td_login()
 
  account_id= '270719431'
  
  position_info=TDSession.get_accounts(account=account_id,fields=['positions'])
  order_info=TDSession.get_accounts(account=account_id,fields=['orders'])
  balances=order_info['securitiesAccount']['currentBalances']
  directional_capital= (balances['buyingPower']+balances['shortBalance']+balances['longMarketValue'])*0.5
  long_capital= (balances['buyingPower']+balances['shortBalance']+balances['longMarketValue'])*0.25
 
  #shares_dict,data_dict=get_current_shares(ticker_list,marginal_capital,'1d')
 
  long_shares,data_dict=get_current_shares(ticker_list,long_capital,'1d',long_only=True,HRP=True,bl1=False)
 
  bl_shares,data_dict=get_current_shares(ticker_list,directional_capital,'1d',HRP=True,long_only=False,bl1=False,method='median')
 
  long_df=pd.Series(long_shares)
  bl_df=pd.Series(bl_shares)
 
  combined=long_df+bl_df
 
  combined[combined.isnull()]=bl_df
  combined[combined.isnull()]=long_df
 
  shares_dict=dict(combined)

  print('shares_dict',shares_dict)
 
  cancel_orders(order_info,TDSession,account_id)
 
  already_dict={}
    
  positions=position_info['securitiesAccount']['positions']
  for position in positions:
    
    ticker=position['instrument']['symbol'].lower() 
  
    size=position['longQuantity'] if position['longQuantity']>position['shortQuantity'] else -position['shortQuantity']
    already_dict[ticker]=size
  
  sign_df=(pd.Series(shares_dict)/pd.Series(already_dict)).dropna()
  sign_df=sign_df[sign_df!=1]
 
  bell_off(already_dict,shares_dict,TDSession,account_id,sign_df)
  #sell_all(already_dict,TDSession,account_id)
  
  #except (KeyError):
    #pass
  
  execute_orders(shares_dict,already_dict,data_dict,TDSession,account_id)

  TDSession=td_login()
  
  position_info=TDSession.get_accounts(account=account_id,fields=['positions'])

  already_dict={}
    
  positions=position_info['securitiesAccount']['positions']
  for position in positions:
    
    ticker=position['instrument']['symbol'].lower() 
  
    size=position['longQuantity'] if position['longQuantity']>position['shortQuantity'] else -position['shortQuantity']
    already_dict[ticker]=size
  
  print(set(shares_dict)-set(already_dict))

def checkbook(ticker,already_dict,shares_dict,sign_df,diff_df):
  return ''.join([in_already(ticker,already_dict),shares_sign(ticker,shares_dict),sign(ticker,sign_df,diff_df),difference(ticker,diff_df,sign_df)])
 
def execute_orders(shares_dict,already_dict,data_dict,TDSession,account_id):
  
  manual={
  'alreadyshares>0sign>0diff>0':buy_diff_conditional_order,
  'alreadyshares>0sign>0diff<0':sell_diff_conditional_order,
  'alreadyshares>0sign<0': buy_otota,                             
  'alreadyshares<0sign>0diff>0': cover_diff_conditional_order,
  'alreadyshares<0sign>0diff<0': short_diff_conditional_order,
  'alreadyshares<0sign<0': short_otota,
  'shares>0': buy_conditional_order,
  'shares<0': short_conditional_order
  }
 
  sign_df=(pd.Series(shares_dict)/pd.Series(already_dict)).dropna()
  sign_df=sign_df[sign_df!=1]
  
  diff_df=(pd.Series(shares_dict)-pd.Series(already_dict)).dropna()
  diff_df=diff_df[(diff_df!=0)]
 
  for ticker in shares_dict:
      if ticker in already_dict and ticker not in sign_df:
        continue
    
    #try:
      data=data_dict[ticker]

      used_data=data[-90:]
      used_data.columns=[col.lower() for col in used_data.columns]
      pos_data=used_data[used_data['close_returns']>0]
      neg_data=used_data[used_data['close_returns']<0]
      pos_std=pandas_ta.stdev(pos_data['close'],length=2)
      pos_std=norm(pos_std[pos_std<pos_std.quantile(0.95)])
      pos_factor=pos_std.std()

      std=pandas_ta.stdev(used_data['close'],length=2)
      std=norm(std[std<std.quantile(0.95)])
      factor=std.std()

      neg_std=pandas_ta.stdev(neg_data['close'],length=2)
      neg_std=norm(neg_std[neg_std<neg_std.quantile(0.95)])
      neg_factor=neg_std.std()

      atr=pandas_ta.atr(used_data['high'],used_data['low'],used_data['close'],length=2).dropna()

      meany=atr.mean()

      y,x,_=plt.hist(atr)

      atr= (np.mean(int(x[np.where(y == y.max())][0]))+meany)/2

      reg_stop=data['close'].iloc[-1]*0.04

      neg_loss=max(0.01,as_currency(min(reg_stop,2.5*atr*neg_factor)))

      neg_profit=as_currency(max(0.01,profit_take(neg_std.iloc[-1],neg_loss),profit_takes(neg_std.iloc[-1])))

      pos_loss=max(0.01,as_currency(min(reg_stop,2.5*atr*pos_factor)))

      pos_profit=as_currency(max(0.01,profit_take(pos_std.iloc[-1],pos_loss),profit_takes(pos_std.iloc[-1])))

      if shares_dict[ticker]>0:
        take_profit=pos_profit
        stop_loss=pos_loss
      else:
        take_profit=neg_profit
        stop_loss=neg_loss

      manual[checkbook(ticker,already_dict,shares_dict,sign_df,diff_df)](take_profit,stop_loss,already_dict,shares_dict,ticker,diff_df,sign_df,account_id,TDSession)
    
    #except Exception as e:
      #print(e)
      #print(ticker)
      #pass
    
    
def cancel_orders(order_info,TDSession,account_id):
  filter=['CANCELED','REJECTED','EXPIRED']
  
  if 'orderStrategies' in order_info['securitiesAccount']:
    for order in order_info['securitiesAccount']['orderStrategies']:
      if order['status'] in filter:
        continue
      else:
        try:
          order_iterator(order,filter,TDSession,account_id)
        
        except Exception as e:
          print(e)
          pass

def order_iterator(order,filter,TDSession,account_id):
  
  if ('childOrderStrategies' in order) and (order['status']=='FILLED'):
    child_order=order['childOrderStrategies'][0]
    while (not child_order['cancelable']) and ('childOrderStrategies' in child_order):
      child_order=child_order['childOrderStrategies'][0]

    order=child_order
    
    if order['cancelable']:
      try:
        TDSession.cancel_order(account_id,order['orderId'])

      except Exception as e:
        print(e)
        pass
  
  elif order['status'] not in filter and (order['cancelable']):
    TDSession.cancel_order(account_id,order['orderId'])
    
def td_login():
    consumer_key='*********************'  
    callback_url='*******************'
    account_id = '*********'          
    client_id=consumer_key
 
    TDSession = TDClient(
        client_id=client_id,
        redirect_uri=callback_url,
        credentials_path=r'C:\Users\Michael\creds.json' 
    )
 
    print(TDSession.login())
    return TDSession
 
 
def sell_off(already_dict,TDSession,shares_dict,account_id):
  for ticker in already_dict:
    if ticker not in shares_dict:
      #try:
        if already_dict[ticker]>0:
          sell_order=market_order(ticker,already_dict[ticker],TDSession,account_id,sell=True) #sell all the ones we don't need anymore
        elif already_dict[ticker]<0:
          sell_order=market_order(ticker,already_dict[ticker],TDSession,account_id,sell=True,short=True)
        
      #except:
        #pass
 
def sell_all(already_dict,TDSession,account_id):
  
  for ticker in already_dict:
    try:
      if already_dict[ticker]>0:
        #order=market_order(ticker,already_dict[ticker],sell=True)
        
        order=sell_anytime(ticker,already_dict[ticker],TDSession,account_id)
       
        
      elif already_dict[ticker]<0:
        #order=market_order(ticker,already_dict[ticker],sell=True,short=True)
       
        order=sell_anytime(ticker,already_dict[ticker],TDSession,account_id,short=True)
        
      #TDSession.place_order(account=account_id,order=order)
    except Exception as e:
      print(e)
      print(ticker)
      pass
 
def bell_off(already_dict,shares_dict,TDSession,account_id,diff_df):
 
  diff_set=set(already_dict)-(set(shares_dict))
 
  diff_dict={key:already_dict[key] for key in diff_set}
 
  for ticker in diff_df.index: 
    if  (ticker in diff_dict and diff_dict[ticker]>0) or (diff_df[ticker]<0 and shares_dict[ticker]<0):
      market_order(ticker,already_dict[ticker],TDSession,account_id,sell=True)
    elif (ticker in diff_dict and diff_dict[ticker]<0) or (diff_df[ticker]<0 and shares_dict[ticker]>0):
      market_order(ticker,already_dict[ticker],TDSession,account_id,sell=True,short=True)
 
def liquid_check(ticker_list):
  liquid_list=[]
  for ticker in ticker_list:
    info=finviz.get_stock(ticker)
    
    rel_vol=float(info['Rel Volume'])
    vol=float(info['Volume'].replace(',',''))
    
    if rel_vol>=0.65 and vol>1000000:
      print(ticker)
      liquid_list.append(ticker)
  
  return liquid_list

def profit_take(volatility,stop_loss):
  return abs(3.9*volatility-0.1*stop_loss)

def cancel_single(ticker):

  TDSession=td_login()

  account_id= '270719431'

  order_info=TDSession.get_accounts(account=account_id,fields=['orders'])

  orders=order_info['securitiesAccount']['orderStrategies']

  filter=['CANCELED','REJECTED','EXPIRED']

  for order in orders:
    if (order['orderLegCollection'][0]['instrument']['symbol']==ticker.upper()):
      #TDSession.cancel_order(account_id,order['orderId'])

      order_iterator(order,filter,TDSession,account_id)

def profit_takes(volatility):
  return abs(1.007211 - 1.743677/2**(volatility/0.5051997))

from time import sleep
def brokerage_updater(ticker_list):
  
    TDSession=td_login()

    account_id= '270719431'

    position_info=TDSession.get_accounts(account=account_id,fields=['positions'])
    order_info=TDSession.get_accounts(account=account_id,fields=['orders'])
    balances=order_info['securitiesAccount']['currentBalances']
    directional_capital=(balances['buyingPower']+balances['shortBalance']+balances['longMarketValue'])*0.4
    long_capital=(balances['buyingPower']+balances['shortBalance']+balances['longMarketValue'])*0.15
          
    while True:
      if dt.datetime.now().time()> dt.time(19,45) and dt.datetime.now().time()< dt.time(19,50):
        print('executing brokerage')
        execute_brokerage(ticker_list)
        break
    
      long_shares,data_dict=get_current_shares(ticker_list,long_capital,'1d',long_only=True,HRP=True,bl1=False,method='median')

      bl_shares,data_dict=get_current_shares(ticker_list,directional_capital,'1d',HRP=True,long_only=False,bl1=False,method='median')

      long_df=pd.Series(long_shares)
      bl_df=pd.Series(bl_shares)

      combined=long_df+bl_df

      combined[combined.isnull()]=bl_df
      combined[combined.isnull()]=long_df

      shares_dict=dict(combined)

      TDSession=td_login()

      account_id= '270719431'

      position_info=TDSession.get_accounts(account=account_id,fields=['positions'])
      order_info=TDSession.get_accounts(account=account_id,fields=['orders'])

      already_dict={}

      positions=position_info['securitiesAccount']['positions']
      for position in positions:
        
        ticker=position['instrument']['symbol'].lower() 

        size=position['longQuantity'] if position['longQuantity']>position['shortQuantity'] else -position['shortQuantity']
        already_dict[ticker]=size

      remaining_dict=(set(shares_dict)-set(already_dict))
      
      for ticker in remaining_dict:
        data=yahooTA(ticker,'1d')

        used_data=data[-90:]
        used_data.columns=[col.lower() for col in used_data.columns]
        pos_data=used_data[used_data['close_returns']>0]
        neg_data=used_data[used_data['close_returns']<0]
        pos_std=pandas_ta.stdev(pos_data['close'],length=2)
        pos_std=norm(pos_std[pos_std<pos_std.quantile(0.95)])
        pos_factor=pos_std.std()

        std=pandas_ta.stdev(used_data['close'],length=2)
        std=norm(std[std<std.quantile(0.95)])
        factor=std.std()

        neg_std=pandas_ta.stdev(neg_data['close'],length=2)
        neg_std=norm(neg_std[neg_std<neg_std.quantile(0.95)])
        neg_factor=neg_std.std()

        atr=pandas_ta.atr(used_data['high'],used_data['low'],used_data['close'],length=2).dropna()

        meany=atr.mean()

        y,x,_=plt.hist(atr)

        atr= (np.mean(int(x[np.where(y == y.max())][0]))+meany)/2

        reg_stop=data['close'].iloc[-1]*0.04

        neg_loss=max(0.01,as_currency(min(reg_stop,2.5*atr*neg_factor)))

        neg_profit=as_currency(max(0.01,profit_take(neg_std.iloc[-1],neg_loss),profit_takes(neg_std.iloc[-1])))

        pos_loss=max(0.01,as_currency(min(reg_stop,2.5*atr*pos_factor)))

        pos_profit=as_currency(max(0.01,profit_take(pos_std.iloc[-1],pos_loss),profit_takes(pos_std.iloc[-1])))

        if shares_dict[ticker]>0:
          conditional_trail_order(pos_profit,pos_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id,short=False,sell=False)
        
        elif shares_dict[ticker]<0:
          conditional_trail_order(neg_profit,neg_loss,ticker,shares_dict[ticker],shares_dict[ticker],TDSession,account_id,short=True,sell=False)
      sleep(60*9)

ticker_list=['vrtx','calx','aeis','vivo','tpx','acls','amat','mitk','hibb','dell','nx','prg','lh','stc','frd','dks','tpr','lpx','bdsi','agco','exp','pki','tsla','rvlv','goog','leu','msft','xom']

#lake,drd,irbt,hear,bgfv

brokerage_updater(ticker_list)

execute_brokerage(ticker_list)
